好的！我将以数组 `[6, 2, 8, 3, 1]` 为例，结合代码片段演示关键排序过程。请准备好纸笔，我们开始画流程图啦！

---

### **1. 冒泡排序演示**
**代码片段**：
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

**排序流程**：
```
初始：[6,2,8,3,1]
第1轮：
 6>2 → 交换 → [2,6,8,3,1]
 6<8 → 保持
 8>3 → 交换 → [2,6,3,8,1]
 8>1 → 交换 → [2,6,3,1,8] → 最大8沉底

第2轮：
 2<6 → 保持
 6>3 → 交换 → [2,3,6,1,8]
 6>1 → 交换 → [2,3,1,6,8] → 次大6到位

第3轮：
 2<3 → 保持
 3>1 → 交换 → [2,1,3,6,8] → 第三大3到位

第4轮：
 2>1 → 交换 → [1,2,3,6,8] → 完成
```

---

### **2. 选择排序演示**
**代码片段**：
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

**排序流程**：
```
初始：[6,2,8,3,1]
第1轮找最小：
 遍历全部找到1 → 交换6和1 → [1,2,8,3,6]

第2轮在剩余中找最小：
 剩余[2,8,3,6]中最小2 → 已正确位置

第3轮在剩余中找最小：
 剩余[8,3,6]中最小3 → 交换8和3 → [1,2,3,8,6]

第4轮在剩余中找最小：
 剩余[8,6]中最小6 → 交换 → [1,2,3,6,8]
```

---

### **3. 插入排序演示**
**代码片段**：
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
```

**排序流程**：
```
初始：[6,2,8,3,1]
处理第1个元素2：
 2 < 6 → 6右移 → [2,6,8,3,1]

处理第2个元素8：
 8 > 6 → 保持 → [2,6,8,3,1]

处理第3个元素3：
 3 < 8 → 8右移
 3 < 6 → 6右移 → 插入 → [2,3,6,8,1]

处理第4个元素1：
 1依次与8、6、3、2比较，全部右移 → 插入最前 → [1,2,3,6,8]
```

---

### **4. 快速排序演示**
**代码片段**：
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

**排序流程**：
```
初始：[6,2,8,3,1] → 选基准3
分割：
 left [2,1] | middle [3] | right [6,8]
递归处理left [2,1]:
 选基准1 → left [] + middle [1] + right [2]
递归处理right [6,8]:
 选基准8 → left [6] + middle [8] → 合并得[6,8]
最终合并：[1,2,3] + [6,8] → [1,2,3,6,8]
```

---

### **5. 归并排序演示**
**代码片段**：
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr)//2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result
```

**排序流程**：
```
拆分阶段：
[6,2,8,3,1] → [6,2] 和 [8,3,1]
[6,2] → [6] 和 [2]
[8,3,1] → [8] 和 [3,1] → [3] 和 [1]

合并阶段：
合并[6]和[2] → [2,6]
合并[3]和[1] → [1,3]
合并[8]和[1,3] → [1,3,8]
最终合并[2,6]和[1,3,8] → [1,2,3,6,8]
```

---

### **6. 堆排序演示**
**代码片段**：
```python
def heap_sort(arr):
    n = len(arr)
    # 建堆
    for i in range(n//2-1, -1, -1):
        heapify(arr, n, i)
    # 逐层取最大
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

def heapify(arr, n, i):
    largest = i
    l = 2*i + 1
    r = 2*i + 2
    if l < n and arr[l] > arr[largest]:
        largest = l
    if r < n and arr[r] > arr[largest]:
        largest = r
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
```

**排序流程**：
```
初始数组：       6
             /   \
            2     8
           / \
          3   1

建堆过程（大顶堆）：
第一次调整节点2 → 交换3和2
第二次调整节点6 → 交换8和6
最终堆结构：
              8
            /   \
           3     6
          / \
         2   1

排序阶段：
取8放最后 → [6,3,2,1,8]
调整堆 → 6下沉与3交换 → 新堆：
              3
            /   \
           1     2
取6放最后 → [2,1,3,6,8]
继续调整...
最终得到[1,2,3,6,8]
```

---

### 流程对比总结表
| 算法     | 关键操作                     | 轮次特点                  |
|----------|------------------------------|--------------------------|
| 冒泡排序 | 相邻元素交换                 | 每轮确定一个最大值沉底    |
| 选择排序 | 扫描找最值交换               | 每轮确定一个最值到正确位置|
| 插入排序 | 元素插入已排序序列           | 类似整理扑克牌            |
| 快速排序 | 基准值分区                   | 分治思想的典型体现        |
| 归并排序 | 分拆-合并                   | 需要额外存储空间          |
| 堆排序   | 建堆与堆调整                 | 树形结构的巧妙应用        |

建议拿扑克牌实际模拟这些过程，你会感受到算法如同魔法般将混乱变为有序！( •̀ ω •́ )✧