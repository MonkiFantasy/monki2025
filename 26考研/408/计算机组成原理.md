## 是否深陷原码反码补码的漩涡无法自拔，掌握overflow的概念就可以挣脱
==up主 饭神来了 408补习班第八期==
int 在计算机中是有限的整数序列
既然是有限的，那就必然有溢出（Overflow）
溢出因为bit的位数是固定的

引入负数/有符号数的二进制表示后：
**存在两个问题**：
- 0有+0和-0两种表示
- 负数的加减法doesn't work
**eg.** 001(1)+101 (-1)= 110(-2)
**To make it work**:
引入另外一种表示法
让001+（-1）=000
那这个-1应该用什么表示呢，没错就是111
001 + 111 = 1 000（发生了溢出）
**找到了-1的表示，那-2怎么表示呢?**
- -1 -1 =-2
- 111 -001 = 110
可以看到it still works
验证一下：
- -2 +2 =0
- 110 + 010 = 1 000（overfow）对了
- -2 + 5 =3
- 110 + 101 =  1 011（overflow）对了 
**下面用简单的方式找到-x的表示方法**：
Flipping each bit and adding 1:
-x = ~x+1
5
- 0101 This is 5
- 1010 This is the "Ones complement of 5" 5 with bit filpped
- 1011 This is the "Twos complement of 5" 5 with bit filpped and added 1
比如前面的-1 
- 01 flip 10
- add 1 ->11
- 加上符号111
把111称为1的Twos complemnt of 1
"**Ones complement of** x"在中文教材里被翻译为**反码**
"**Twos complement of x**"在中文教材里被翻译为**补码**
[[补码相关|对于相关翻译deepseek的理解]]

 **They are called complements because complementary bits are set.If they are added, all bits are necessarily set:**
 **把比特位填满**
 0101 +1010 =1111

**Adding 1 to the  sum of a number and its complement necessarily results in a 0 due to overflow** 
**通过+1溢出得到0**
(0101 + 1010 ) + 1 = 1111 +1 = 1 0000 （0）
**这完美利用了溢出的方式实现了对一个数负数的表示**

**And if x+y=0,y must equal -x**

补码的引入是为了解决负数的计算，利用了溢出(overflow)的概念使得正数+负数=0
有符号数以及无符号数对于二进制数的映射
**拆解**：
对于有符号数可以看成一个最大的负数加上一个正数，
如1010
- 1000 （-8）
- 0010  （2）
- 1000 + 0010 = 1010 (-8 +2 =-6)
同理对于无符号数拆成一个最大的正数加上一个正数：
- 1000 （8）
- 0010 （2）
- 1000 + 0010 =1010 （8+2=10）
![[Pasted image 20250311154037.png]]
## 第三章 存储系统
[[考纲#三、存储器层次结构|408大纲]]
### 层次结构
```mermaid
%% 补充CPU与主存双向访问的存储层次图
flowchart TD
    A[CPU] -->|直接访问\n（1~5 ns）| B[Cache\n（SRAM）]
    B -->|命中\n（5~10 ns）| A
    B -->|未命中| C[主存\n（DRAM）]
    C -->|加载数据\n（50~100 ns）| B
    C -->|未命中| D[辅存\n（磁盘/SSD）]
    D -->|加载数据\n（ms级）| C

    %% 新增CPU与主存的双向箭头
    A <-->|"直接访问（绕过Cache）\n（50~100 ns）"| C

    %% 层级特性标注
    classDef speed fill:#f9f,stroke:#333;
    classDef capacity fill:#9ff,stroke:#333;
    class A,B,C,D speed
    class B,C,D capacity

    %% 特性说明
    A -.->|"速度：最快\n容量：最小\n成本：最高"| A
    B -.->|"速度：快\n容量：MB级\n成本：高"| B
    C -.->|"速度：中\n容量：GB级\n成本：中"| C
    D -.->|"速度：慢\n容量：TB级\n成本：低"| D
```
 ==主存-辅存==之间交换 由硬件和操作系统完成 系统程序员需要完成操作系统的页面置换算法
- 实现虚拟存储系统，解决主存容量不够的问题
==cache-主存==之间交换由硬件工程师实现 对于系统程序员是透明的
- 解决了CPU 主存之间速度不匹配的问题
### 分类
1. 按照层次分类
2. 按存储介质分类
3. 按存取方式分类
4. 按信息的可更改性
5. 按信息的可保存性
- DRAM和SRAM [[RAM相关]]
### 性能指标
- 存储容量
- 单位成本（每bit价格）
- 数据传输率（主存带宽）
- 存储周期=存取时间+恢复时间
### 存储器芯片基本结构
- 存储体
- MAR
- MDR
![[Screenshot_2025-03-09-15-40-51-823_tv.danmaku.bili.jpg]]
字位线的理解参考这个视频：【用最好的动画为你讲解--内存的原理-哔哩哔哩】 https://b23.tv/QW3yoVf

### SRAM和DRAM
- DRAM Dynamic Random Access Memory 动态RAM
- SRAM Static Random Access Memory 静态RAM
- SDRAM Synchonous Dynamic Random Access Memory 动态RAM
都属于**断电易失**

**~~DRAM~~用于主存**（现过时，通常采用**SDRAM**）
- 使用**栅极电容**存储信息，破坏性读出，需要重写，速度更慢
- 每个存储源电路简单，制造成本更低，集成度高，功耗低
- 需要刷新
- 分两次送行列地址（地址线复用技术->地址线、地址引脚减半）
**SRAM用于cache**
- 使用**双稳态触发器**存储信息，非破坏性读出，无需重写，速度更快
- 每个存储元电路较栅极电容更复杂，集成度成本更高，集成度低，功耗大
- 无需刷新
- 同时送行列地址（集成度低）
**DRAM的刷新**
多久刷新一次：刷新周期，通常是2ms
每次刷新多少存储单元：一行
使用行列地址：减少选通线的数量 16x16 ->16+16
如何刷新：有硬件支持，读出一行信息，然后把这个信息重新写入，占一个读写周期
在什么时候刷新：
- 分散刷新
- 集中刷新
- 异步刷新
